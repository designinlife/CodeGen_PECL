<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>PECL_Gen - the PHP extension generator</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="book"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN1"
><TT
CLASS="literal"
>PECL_Gen</TT
> - the PHP extension generator</A
></H1
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#AEN4"
>Introduction</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#AEN6"
>What is it?</A
></DT
><DT
>1.2. <A
HREF="#AEN19"
>Features</A
></DT
><DT
>1.3. <A
HREF="#AEN38"
>How to use it</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#AEN49"
>The XML description</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#AEN51"
>Basics</A
></DT
><DT
>2.2. <A
HREF="#AEN64"
>Release information</A
></DT
><DT
>2.3. <A
HREF="#AEN96"
>Dependencies</A
></DT
><DD
><DL
><DT
>2.3.1. <A
HREF="#AEN119"
><TT
CLASS="literal"
>--with...</TT
></A
></DT
><DT
>2.3.2. <A
HREF="#AEN138"
>Libraries</A
></DT
><DT
>2.3.3. <A
HREF="#AEN152"
>Header files</A
></DT
></DL
></DD
><DT
>2.4. <A
HREF="#AEN167"
>Custom code</A
></DT
><DT
>2.5. <A
HREF="#AEN178"
>Functions</A
></DT
><DD
><DL
><DT
>2.5.1. <A
HREF="#AEN188"
>Public functions</A
></DT
><DT
>2.5.2. <A
HREF="#AEN232"
>Internal functions</A
></DT
></DL
></DD
><DT
>2.6. <A
HREF="#AEN280"
>Constants</A
></DT
><DT
>2.7. <A
HREF="#AEN297"
><TT
CLASS="literal"
>php.ini</TT
> parameters and internal variables</A
></DT
><DT
>2.8. <A
HREF="#AEN369"
>Resources</A
></DT
><DD
><DL
><DT
>2.8.1. <A
HREF="#AEN391"
>Resource creation and destruction</A
></DT
></DL
></DD
><DT
>2.9. <A
HREF="#AEN402"
>Classes</A
></DT
><DT
>2.10. <A
HREF="#AEN405"
>Streams</A
></DT
><DT
>2.11. <A
HREF="#AEN408"
>config.m4 fragments</A
></DT
><DT
>2.12. <A
HREF="#AEN415"
>Makefile fragments</A
></DT
><DT
>2.13. <A
HREF="#AEN422"
>Tests</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#AEN427"
>XML input parsing</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#AEN429"
>Includes</A
></DT
><DD
><DL
><DT
>3.1.1. <A
HREF="#AEN442"
>External entities</A
></DT
><DT
>3.1.2. <A
HREF="#AEN445"
>XInclude</A
></DT
><DT
>3.1.3. <A
HREF="#AEN448"
><CODE
CLASS="sgmltag"
>code</CODE
> tags</A
></DT
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Examples</B
></DT
><DT
>2-1. <A
HREF="#AEN61"
>Extension basics</A
></DT
><DT
>2-2. <A
HREF="#AEN73"
>Release information</A
></DT
><DT
>2-3. <A
HREF="#AEN84"
>License</A
></DT
><DT
>2-4. <A
HREF="#AEN93"
>A logo image</A
></DT
><DT
>2-5. <A
HREF="#AEN116"
>Dependencies</A
></DT
><DT
>2-6. <A
HREF="#AEN134"
><TT
CLASS="literal"
>--with...</TT
></A
></DT
><DT
>2-7. <A
HREF="#AEN149"
>Library dependencies</A
></DT
><DT
>2-8. <A
HREF="#AEN164"
>Header file dependencies</A
></DT
><DT
>2-9. <A
HREF="#AEN243"
><TT
CLASS="literal"
>MINIT()</TT
></A
></DT
><DT
>2-10. <A
HREF="#AEN274"
><TT
CLASS="literal"
>MINFO()</TT
></A
></DT
><DT
>2-11. <A
HREF="#AEN294"
>PHP Constants</A
></DT
><DT
>2-12. <A
HREF="#AEN362"
>Globals</A
></DT
><DT
>2-13. <A
HREF="#AEN366"
>Globals</A
></DT
><DT
>2-14. <A
HREF="#AEN388"
>Resources</A
></DT
><DT
>2-15. <A
HREF="#AEN395"
>Resource creation</A
></DT
><DT
>2-16. <A
HREF="#AEN399"
>Resource destruction</A
></DT
><DT
>2-17. <A
HREF="#AEN412"
>config.m4 additions</A
></DT
><DT
>2-18. <A
HREF="#AEN419"
>Makefile fragments</A
></DT
></DL
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="AEN4"
></A
>Chapter 1. Introduction</H1
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN6"
>1.1. What is it?</A
></H2
><P
>&#13;    <TT
CLASS="literal"
>PECL_Gen</TT
> is a tool that can automatically create
    the basic framework for a PHP extension from a rather simple XML
    specification file.
   </P
><P
>&#13;    It also supports the simpler (but less powerful) prototype file
    format as used by the shell script <TT
CLASS="literal"
>ext_skel</TT
> that
    is distributed togehter with the PHP source code.
   </P
><P
>&#13;    <TT
CLASS="literal"
>PECL_Gen</TT
>, unlike the older
    <TT
CLASS="literal"
>ext_skel</TT
> solution, is a 100% PHP 5 bases
    solution and does not require any external tools like
    <TT
CLASS="literal"
>awk</TT
> or <TT
CLASS="literal"
>sed</TT
>. It only uses PHP
    functions that are always enabled in a default build so it should
    be usable on any platform that PHP itself runs on.
   </P
><P
>&#13;    The code generated by <TT
CLASS="literal"
>PECL_Gen</TT
> is designed to work 
    with both the PHP 4 and PHP 5 extension APIs, PHP 5 is only required
    for the conversion of the XML spec file to C/C++ code. 
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN19"
>1.2. Features</A
></H2
><P
>&#13;    <TT
CLASS="literal"
>pecl-gen</TT
> tries to support as many extension
    writing aspects as possible. This currently includes code and documentation
    generation for:
    <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>functions</TD
></TR
><TR
><TD
>constants</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>php.ini</TT
> configuration directives</TD
></TR
><TR
><TD
>resource types</TD
></TR
><TR
><TD
>per-thread global variables</TD
></TR
></TBODY
></TABLE
><P
></P
>
   </P
><P
>&#13;    <TT
CLASS="literal"
>pecl-gen</TT
> also generates
    <TT
CLASS="filename"
>config.m4</TT
> 
    configuration files for Unix-like build environments,
    VisualStudio <TT
CLASS="filename"
>*.dsp</TT
> project files for Windows
    and the <TT
CLASS="filename"
>package.xml</TT
> files needed for
    PEAR/PECL packaging.
   </P
><P
>&#13;    DocBook XML documentation templates suitable for inclusion in the
    PHP or PEAR manual are generated in the hope that it will ease the
    task of documenting extension.
   </P
><P
>&#13;    Test script templates for automatic regression testing are already 
    created but due to some missing features within the "<TT
CLASS="literal"
>make
     test</TT
>" infrastructure it is not possible to use the
    generated tests with standalone PECL extensions right now.
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN38"
>1.3. How to use it</A
></H2
><P
>&#13;    There are currently three different modes of operation for
    <TT
CLASS="literal"
>pecl-gen</TT
>. In its default mode it can create a complete
    ready-to-compile extension from an XML description (documented in
    the next chapter). In <TT
CLASS="literal"
>ext_skel</TT
> compatibility
    mode it generates the extension from some command line parameters
    and an optional function prototype file and in immediate mode it
    just takes a function prototype from command line and writes a
    C code skeleton for just that function to standard output.
   </P
><P
>&#13;    <TT
CLASS="literal"
>ext_skel</TT
> compatibility and immediate mode are 
    not documented here, please refer to the original 
    <TT
CLASS="literal"
>ext_skel</TT
> documentation instead.
   </P
><P
>&#13;    Below you find a hardcopy of the <TT
CLASS="literal"
>pecl-gen
     --help</TT
> output:
   </P
><PRE
CLASS="screen"
>&#13;pecl-gen [-h] [--extname=name] [--proto=file] [--skel=dir] [--stubs=file] 
  [--no-help] [--xml[=file]] [--full-xml] [--function=proto] [specfile.xml]

  -h|--help          this message
  --force            overwrite existing directories
	--function         create a function skeleton from a proto right away
  --version          show version info

  the following options are inherited from ext_skel:

  --extname=module   module is the name of your extension 
  --proto=file       file contains prototypes of functions to create
  --xml              generate xml documentation to be added to phpdoc-cvs

	these wait for functionality to be implemented and are ignored for now ...
  --stubs=file       generate only function stubs in file
  --no-help          don't try to be nice and create comments in the code
                     and helper functions to test if the module compiled

  these are accepted for backwards compatibility reasons but not used ...
  --full-xml         generate xml documentation for a self-contained extension
                     (this was also a no-op in ext_skel) 
  --skel=dir         path to the skeleton directory
                     (skeleton stuff is now self-contained)
   </PRE
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="AEN49"
></A
>Chapter 2. The XML description</H1
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN51"
>2.1. Basics</A
></H2
><P
>&#13;    The top level container tag describing an extension is the
    <CODE
CLASS="sgmltag"
>extension</CODE
> tag. The name of the extension
    is given in the <TT
CLASS="literal"
>name</TT
> attribute. The extension
    name has to be a valid C name as it is used as both the extensions
    directory name and the base name for several C symbols within the
    generated C code.
   </P
><P
>&#13;    The tags <CODE
CLASS="sgmltag"
>summary</CODE
> and
    <CODE
CLASS="sgmltag"
>description</CODE
> should be added at the very top of
    your extensions. The summary should be a short one-line
    description of the extension while the actually description can be
    as detailed as you like. Both are later used to generate the
    <TT
CLASS="literal"
>package.xml</TT
> file and the documentation for your
    extension. The summary line is also put into the
    <TT
CLASS="literal"
>phpinfo()</TT
> output of your extension.
   </P
><DIV
CLASS="example"
><A
NAME="AEN61"
></A
><P
><B
>Example 2-1. Extension basics</B
></P
><PRE
CLASS="programlisting"
>&#13;
&#60;extension name="sample"&#62;
 &#60;summary&#62;A sample PHP extension&#60;/summary&#62;
 &#60;description&#62;
  This is a sample extension specification
  showing how to use PECL_Gen for
  extension generation.
 &#60;/description&#62;
 ...

    </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN64"
>2.2. Release information</A
></H2
><P
>&#13;    The release information for your extension should include the
    extension authors and maintainers, the version number, state and
    release date, the chosen license and maybe a change log describing
    previous releases. It is also possible to specify an image file
    to be used as a product logo with the <TT
CLASS="literal"
>phpinfo()</TT
>
    output block for the extension.
   </P
><P
>&#13;    The <CODE
CLASS="sgmltag"
>maintainers</CODE
>, <CODE
CLASS="sgmltag"
>release</CODE
> and
    <CODE
CLASS="sgmltag"
>changelog</CODE
> tags specifications are identical to  
    those in  the PEAR <TT
CLASS="literal"
>package.xml</TT
> specification so 
    please refer to the PEAR documentation here.
   </P
><DIV
CLASS="example"
><A
NAME="AEN73"
></A
><P
><B
>Example 2-2. Release information</B
></P
><PRE
CLASS="programlisting"
>&#13;
...
  &#60;maintainers&#62;
    &#60;maintainer&#62;
      &#60;user&#62;hholzgra&#60;/user&#62;
      &#60;name&#62;Hartmut Holzgraefe&#60;/name&#62;
      &#60;email&#62;hartmut@php.net&#60;/email&#62;
      &#60;role&#62;lead&#60;/role&#62;
    &#60;/maintainer&#62;
  &#60;/maintainers&#62;

  &#60;release&#62;
    &#60;version&#62;1.0&#60;/version&#62;
    &#60;date&#62;2002-07-09&#60;/date&#62;
    &#60;state&#62;stable&#60;/state&#62;
    &#60;notes&#62;
     The sample extension is now stable
    &#60;/notes&#62;
  &#60;/release&#62;

  &#60;changelog&#62;
    &#60;release&#62;
      &#60;version&#62;0.5&#60;/version&#62;
      &#60;date&#62;2002-07-05&#60;/date&#62;
      &#60;state&#62;beta&#60;/state&#62;
      &#60;notes&#62;First beta version&#60;/notes&#62;
    &#60;release&#62;
    &#60;release&#62;
      &#60;version&#62;0.1&#60;/version&#62;
      &#60;date&#62;2002-07-01&#60;/date&#62;
      &#60;state&#62;alpha&#60;/state&#62;
      &#60;notes&#62;First alpha version&#60;/notes&#62;
    &#60;release&#62;
  &#60;/changelog&#62;
...

    </PRE
></DIV
><P
>&#13;    The <CODE
CLASS="sgmltag"
>license</CODE
> tag is a little more restrictive as
    its <TT
CLASS="literal"
>package.xml</TT
> counterpart as it is used to
    decide which license text should actually be written to the
    <TT
CLASS="literal"
>LICENSE</TT
>. For now you have to specify either
    <TT
CLASS="literal"
>PHP</TT
>, <TT
CLASS="literal"
>BSD</TT
> or
    <TT
CLASS="literal"
>LGPL</TT
>, any other value is taken as
    '<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>unknown</I
></SPAN
>'.
   </P
><DIV
CLASS="example"
><A
NAME="AEN84"
></A
><P
><B
>Example 2-3. License</B
></P
><PRE
CLASS="programlisting"
>&#13;
...
  &#60;license&#62;PHP&#60;/license&#62;
...

    </PRE
></DIV
><P
>&#13;    A logo to be used within the extensions
    <TT
CLASS="literal"
>phpinfo()</TT
> block can be specified using the
    <CODE
CLASS="sgmltag"
>logo</CODE
> tag. The actual file name of the logo
    image has to be given in the <TT
CLASS="literal"
>scr=...</TT
> attribute,
    Its MIME type defaults to <TT
CLASS="literal"
>image/gif</TT
> unless a
    different type is specified using the
    <TT
CLASS="literal"
>mimetype=...</TT
> attribute. Automatic MIME type
    detection is planned for a future release. 
   </P
><DIV
CLASS="example"
><A
NAME="AEN93"
></A
><P
><B
>Example 2-4. A logo image</B
></P
><PRE
CLASS="programlisting"
>&#13;
...
  &#60;logo src="sample_logo.gif" mimetype="image/gif" /&#62;
...

    </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN96"
>2.3. Dependencies</A
></H2
><P
>&#13;    Dependencies are specified within the <CODE
CLASS="sgmltag"
>deps</CODE
>
    environment. Within the <CODE
CLASS="sgmltag"
>deps</CODE
> itself it is
    possible to set the programming language and target platforms using
    the <TT
CLASS="literal"
>language=...</TT
> and
    <TT
CLASS="literal"
>platform=...</TT
> attributes.
   </P
><P
>&#13;    Supported languages are C (<TT
CLASS="literal"
>lang="c"</TT
>) and C++
    (<TT
CLASS="literal"
>language="cpp"</TT
>). The language selection 
    does not influence code generation itself
    (<TT
CLASS="literal"
>pecl-gen</TT
> always generates C code) but the way
    extensions are compiled and linked. C++ should only be selected to
    interface to external C++ libraries.
   </P
><P
>&#13;    Supported platforms are currently Unix-like systems
    (<TT
CLASS="literal"
>platform="unix"</TT
>), Microsoft Windows
    (<TT
CLASS="literal"
>platform="win32"</TT
>) or both (<TT
CLASS="literal"
>platform="all"</TT
>).
   </P
><P
> 
    <CODE
CLASS="sgmltag"
>with</CODE
>, <CODE
CLASS="sgmltag"
>lib</CODE
> and 
    <CODE
CLASS="sgmltag"
>header</CODE
> tags may be used within the 
    <CODE
CLASS="sgmltag"
>deps</CODE
> section to add configure switches 
    and library and header file dependencies.
   </P
><DIV
CLASS="example"
><A
NAME="AEN116"
></A
><P
><B
>Example 2-5. Dependencies</B
></P
><PRE
CLASS="programlisting"
>&#13;
...
  &#60;deps language="cpp" platform="win32"&#62;
  ...
  &#60;/deps&#62;
...

    </PRE
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN119"
>2.3.1. <TT
CLASS="literal"
>--with...</TT
></A
></H3
><P
>&#13;     When building an extension on Unix-like systems or within the
     Cygwin environment under Windows the <TT
CLASS="literal"
>configure</TT
>
     script will try to figure out where external libraries and header
     files needed by an extension are installed on the build system.
     Using a "with" option it is possible to specify where to actually
     look for libraries and headers. This way it is possible to
     override search paths if things are not installed in the default
     system paths or to specify the exact version of a package to be
     used if multiple versions are installed on the target system.
    </P
><P
>&#13;     The <CODE
CLASS="sgmltag"
>with</CODE
> tag takes three attributes:
     <TT
CLASS="literal"
>name=...</TT
> for the actual name of the "with"
     option, <TT
CLASS="literal"
>testfile</TT
> for the relative path of a
     file to check for while running the <TT
CLASS="literal"
>configure</TT
>
     script and a list of default paths to check if no path is given
     as an argument to the "with" option in
     <TT
CLASS="literal"
>defaults</TT
>. 
    </P
><P
>&#13;     Name and defaults are set to the extension base name and
     "/usr:/usr/local" if no values are given. The testfile attribute
     is mandatory.
    </P
><P
>&#13;     Textual data enclosed by the <CODE
CLASS="sgmltag"
>with</CODE
> is used to
     describe the "with" option in the output of <TT
CLASS="literal"
>configure
      --help</TT
> calls.
    </P
><DIV
CLASS="example"
><A
NAME="AEN134"
></A
><P
><B
>Example 2-6. <TT
CLASS="literal"
>--with...</TT
></B
></P
><PRE
CLASS="programlisting"
> 
 
... 
    &#60;with defaults='/usr:/usr/local' testfile='include/sample.h'&#62;sample install&#60;/with&#62; 
... 

      </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN138"
>2.3.2. Libraries</A
></H3
><P
>&#13;     Needed external libraries are specified using the
     <CODE
CLASS="sgmltag"
>lib</CODE
> tag. The <TT
CLASS="literal"
>name=...</TT
>
     attribute is mandatory and takes the library base name. A library
     dependency by the name "sample" is actually referring to a library
     file named <TT
CLASS="filename"
>libsample.a</TT
> for a static or  
     <TT
CLASS="filename"
>libsample.so</TT
> for a dynamic library on
     Unix-like systems or to <TT
CLASS="filename"
>sample.DLL</TT
> on
     Windows.
    </P
><P
>&#13;     It is possible to specify the name of a function symbol expected
     to be provided by the library using the
     <TT
CLASS="literal"
>function=...</TT
> attribute. This function symbol
     is being looked for when <TT
CLASS="literal"
>configure</TT
> is run for
     the extension. This way it is possible to verify that the right
     version of a library was found. With VisualStudio on windows it
     is not possible to perform this check, in this case the library
     is just added to the project file.
    </P
><DIV
CLASS="example"
><A
NAME="AEN149"
></A
><P
><B
>Example 2-7. Library dependencies</B
></P
><PRE
CLASS="programlisting"
>&#13;
...
    &#60;lib name="sample_u" platform="unix"  function="sample_v2" /&#62;
    &#60;lib name="sample_w" platform="win32" /&#62;
    &#60;lib name="sample"   platform="all" /&#62;
...

     </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN152"
>2.3.3. Header files</A
></H3
><P
>&#13;     It is possible to specify header files needed by the extension
     using the <CODE
CLASS="sgmltag"
>header</CODE
>. Any headers specified have
     to exist in the include path set for compiling (see also the
     section on <TT
CLASS="literal"
>--with</TT
>
     above). <TT
CLASS="literal"
>#include</TT
> statements for the specified
     headers are the last ones to be put into the generated code
     unless you set the <TT
CLASS="literal"
>prepend="yes"</TT
> attribute to
     have it put in front of the other <TT
CLASS="literal"
>#include</TT
>s.
    </P
><P
>&#13;     By default header files are searched for in the <TT
CLASS="literal"
>include</TT
>
     subdirectory of the path given in <CODE
CLASS="sgmltag"
>with</CODE
>. If a
     different relative path needs to be used it can be defined using
     the <TT
CLASS="literal"
>path</TT
> attribute.
    </P
><DIV
CLASS="example"
><A
NAME="AEN164"
></A
><P
><B
>Example 2-8. Header file dependencies</B
></P
><PRE
CLASS="programlisting"
>&#13;
...
    &#60;header name="include_me_first.h" prepend="yes" /&#62;
    &#60;header name="sample.h" /&#62;
    &#60;header name="foobar.h" path="include/foo/bar" /&#62;    
...

     </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN167"
>2.4. Custom code</A
></H2
><P
>&#13;    Custom code may be added to your extension source files using the
    <CODE
CLASS="sgmltag"
>code</CODE
> tags. The <TT
CLASS="literal"
>role=...</TT
>
    and <TT
CLASS="literal"
>position=...</TT
> tags specify the actual place
    in there generated source files where your code should be
    inserted.
   </P
><P
>&#13;    Possible roles are '<TT
CLASS="literal"
>code</TT
>' (default) for the generated C
    or C++ code file and '<TT
CLASS="literal"
>header</TT
>' header file.
    Possible positions are '<TT
CLASS="literal"
>top</TT
>' and '<TT
CLASS="literal"
>bottom</TT
>'
    (default) for insertion near the beginning or end of the generated file.
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN178"
>2.5. Functions</A
></H2
><P
>&#13;    Three different kinds of functions may be defined using the
    <CODE
CLASS="sgmltag"
>function</CODE
> tag: public, internal and private
    functions.
    Public functions are functions you want to make available at the
    PHP code level, internal functions are C functions to be used by
    the PHP extension API and private functions are static C helper
    functions to be used within your extension.
   </P
><P
>&#13;    Public function names should by convention be prefixed with the
    extension name followed by an underscore, internal functions are
    one of <TT
CLASS="literal"
>MINIT</TT
>, <TT
CLASS="literal"
>MSHUTDOWN</TT
>,
    <TT
CLASS="literal"
>RINIT</TT
>, <TT
CLASS="literal"
>RSHUTDOWN</TT
> or
    <TT
CLASS="literal"
>MINFO</TT
>, and private functions may have any legal
    C function name (unless you experience duplicate symbol errors
    while compiling or linking the extension).
   </P
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN188"
>2.5.1. Public functions</A
></H3
><P
>&#13;     The definition of a public PHP function requires the attributes 
     <TT
CLASS="literal"
>role="public"</TT
> and
     <TT
CLASS="literal"
>name=...</TT
> and at least the
     <CODE
CLASS="sgmltag"
>proto</CODE
> tag to be set.
    </P
><P
>&#13;     The function name may be any valid C name. To comply to PHP
     coding conventions a public function provided by an extension
     should always be prefixed by the extension name though.
    </P
><P
>&#13;     The function prototype specified using the
     <CODE
CLASS="sgmltag"
>proto</CODE
> tag is parsed to extract the return
     type, the function name and the argument list. The function name
     in the prototype has to match the name attribute given in the
     <CODE
CLASS="sgmltag"
>function</CODE
>.
    </P
><P
>&#13;     Valid types to be used for arguments and the return type are:
     <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><SPAN
CLASS="type"
>bool</SPAN
></TD
></TR
><TR
><TD
><SPAN
CLASS="type"
>int</SPAN
></TD
></TR
><TR
><TD
><SPAN
CLASS="type"
>float</SPAN
></TD
></TR
><TR
><TD
><SPAN
CLASS="type"
>string</SPAN
></TD
></TR
><TR
><TD
><SPAN
CLASS="type"
>array</SPAN
></TD
></TR
><TR
><TD
><SPAN
CLASS="type"
>object</SPAN
></TD
></TR
><TR
><TD
><SPAN
CLASS="type"
>mixed</SPAN
></TD
></TR
><TR
><TD
><SPAN
CLASS="type"
>callback</SPAN
></TD
></TR
><TR
><TD
><SPAN
CLASS="type"
>resource</SPAN
> <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>[typename]</I
></SPAN
></TD
></TR
><TR
><TD
><SPAN
CLASS="type"
>stream</SPAN
></TD
></TR
></TBODY
></TABLE
><P
></P
>
     Argument names in prototypes are not prepended by a <TT
CLASS="literal"
>$</TT
> 
     sign by convention.
    </P
><P
>&#13;     Function documentation should be given using the
     <CODE
CLASS="sgmltag"
>summary</CODE
> tag for a one line description and the
     <CODE
CLASS="sgmltag"
>description</CODE
> tag for a more detailed
     description.
     Both are copied to the generated DocBook XML
     documentation for that function. Within <CODE
CLASS="sgmltag"
>description</CODE
>
     DocBook tags may be used. Be aware though that while <B
CLASS="command"
>pecl-gen</B
>
     accepts this validating XML parsers may complain when reading/validating
     an extension specification file.
    </P
><P
>&#13;     Skeleton code for parameter parsing and result passing is
     generated if  no <CODE
CLASS="sgmltag"
>code</CODE
> fragment is specified
     for a function. A <CODE
CLASS="sgmltag"
>code</CODE
> section is inserted
     right after the generated parameter parsing code. Setting a
     return value is up to the code fragment if any is given, adding a
     template doesn't make sense in this case.
    </P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>&#13;      Maybe some stuff regarding actual coding should be added here?
     </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN232"
>2.5.2. Internal functions</A
></H3
><P
>&#13;     The definition of an internal function requires just the
     <TT
CLASS="literal"
>role="internal"</TT
> and <TT
CLASS="literal"
>name=...</TT
>
     attributes. The name can only be one of the following:
     <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><TT
CLASS="literal"
>MINIT</TT
></DT
><DD
><P
>&#13;         The module initialization function. This is called
         once at startup of a PHP server module or standalone (CLI or
         CGI) binary.
        </P
><DIV
CLASS="example"
><A
NAME="AEN243"
></A
><P
><B
>Example 2-9. <TT
CLASS="literal"
>MINIT()</TT
></B
></P
><PRE
CLASS="programlisting"
>&#13;...
    &#60;function role="internal" name="MINIT"&#62;
      &#60;code&#62;
&#60;![CDATA[
  int dummy = 42;
    
  dummy = dummy;
]]&#62;
      &#60;/code&#62;
    &#60;/function&#62;
...
         </PRE
></DIV
></DD
><DT
><TT
CLASS="literal"
>MSHUTDOWN</TT
></DT
><DD
><P
>&#13;         The module shutdown function. This is called once when the
         PHP server module or standalone binary is properly
         terminated.
         It may not be called on program crashes or other critical errors.
        </P
></DD
><DT
><TT
CLASS="literal"
>RINIT</TT
></DT
><DD
><P
>&#13;         The request shutdown function. This is called by PHP server
         modules before actually executing a PHP script request or once
         right after <TT
CLASS="literal"
>MINIT()</TT
> for standalone
         binaries (CGI or CLI).
        </P
></DD
><DT
><TT
CLASS="literal"
>RSHUTDOWN</TT
></DT
><DD
><P
>&#13;         The request shutdown function. This is called by PHP server
         modules after execution of PHP code has been finished or
         terminated.
         Is called even if critical PHP errors occurred but you can not
         rely on it being called on critical errors or crashes on the
         C level.
        </P
></DD
><DT
><TT
CLASS="literal"
>MINFO</TT
></DT
><DD
><P
>&#13;         The <TT
CLASS="literal"
>phpinfo()</TT
> handler for this extension.
         It will be called whenever <TT
CLASS="literal"
>phpinfo()</TT
> is
         invoked or when a standalone PHP binary is called with the
         <TT
CLASS="literal"
>-i</TT
> command line option.
        </P
><P
>&#13;         The default code generated when no <CODE
CLASS="sgmltag"
>code</CODE
>
         section is given includes the extension name, summary line
         and release version and date, the optional logo image if
         specified, and the global and actual values of all
         <TT
CLASS="literal"
>php.ini</TT
> directives specified.
        </P
><DIV
CLASS="example"
><A
NAME="AEN274"
></A
><P
><B
>Example 2-10. <TT
CLASS="literal"
>MINFO()</TT
></B
></P
><PRE
CLASS="programlisting"
>&#13;...
    &#60;function role='internal' name='MINFO'&#62;
      &#60;code&#62;
&#60;![CDATA[
  php_info_print_table_start();
  php_info_print_table_header(2, "test", "table");
  php_info_print_table_end();
]]&#62;
      &#60;/code&#62;
    &#60;/function&#62;
...
         </PRE
></DIV
></DD
></DL
></DIV
>
    </P
><P
>&#13;     <CODE
CLASS="sgmltag"
>code</CODE
> sections for the internal
     functions may be written as if they were C function bodies,
     including local variable definitions.
    </P
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN280"
>2.6. Constants</A
></H2
><P
>&#13;    PHP constants are defined using <CODE
CLASS="sgmltag"
>constant</CODE
>
    tags within the <CODE
CLASS="sgmltag"
>constants</CODE
> environment.
   </P
><P
>&#13;    The actual constant name, type and value are specified using the
    <TT
CLASS="literal"
>name=...</TT
>, <TT
CLASS="literal"
>type=...</TT
> and
    <TT
CLASS="literal"
>value=...</TT
> attributes. The constant name has to
    be a valid C name. PHP constant names should use uppercase letters
    only by convention. Possible types are "string", "int" and
    "float", the possible values depend on the type. For "int" and
    "float" you may use either numeric strings or the names of C
    constants (either true ANSI C/C++ constants or values
    <TT
CLASS="literal"
>#define</TT
>d using the C preprocessor. "string"
    values are always used "as is", no constants may be used here.
   </P
><P
>&#13;    It is sufficient to specify a constant <TT
CLASS="literal"
>name</TT
>
    only if a C integer constant should be available under the same
    name in PHP, too.
   </P
><P
>&#13;    A descriptive text may be given as content of the
    <CODE
CLASS="sgmltag"
>constant</CODE
> tag. This text will be used when
    generation the DocBook XML documentation.
   </P
><DIV
CLASS="example"
><A
NAME="AEN294"
></A
><P
><B
>Example 2-11. PHP Constants</B
></P
><PRE
CLASS="programlisting"
>&#13;
...
 &#60;constants&#62;
  &#60;constant name="SAMPLE_INT"   type="int"    value="42"&#62;
   A sample integer constant.
  &#60;/constant&#62;
  &#60;constant name="SAMPLE_FLOAT" type="float"  value="3.14"&#62;
   A sample floating point constant.
  &#60;/constant&#62;
  &#60;constant name="SAMPLE_FLOAT" type="float"  value="M_PI"&#62;
   A sample floating point constant using a #defined constant
  &#60;/constant&#62;
  &#60;constant name="SAMPLE_STRING" type="string" value="Hello World!"&#62;
   A sample string constant.
  &#60;/constant&#62;
  &#60;constant name="MY_CONST"&#62;
    A shortcat for #defined integer constants
  &#60;/constant&#62;
 &#60;/constants&#62;
...

    </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN297"
>2.7. <TT
CLASS="literal"
>php.ini</TT
> parameters and internal variables</A
></H2
><P
>&#13;    An extension may define variables that are global to either the
    complete extension or to a specific request. True globals that are
    global to the complete extensions do not need any registration so
    they can be defined using C code within the global <CODE
CLASS="sgmltag"
>code</CODE
> 
    tag.
   </P
><P
>&#13;    Module globals that are only global to a single request need to
    be managed to ensure thread safety and initialization on request
    initialization. <TT
CLASS="literal"
>php.ini</TT
> directive values are
    also stored as module globals but need some additional definitions.
   </P
><P
>&#13;    All global definitions have to be put into a
    <CODE
CLASS="sgmltag"
>globals</CODE
> environment. Simple module globals are
    defined using the <CODE
CLASS="sgmltag"
>global</CODE
>
    tag. <TT
CLASS="literal"
>php.ini</TT
> directives are defined using the
    <CODE
CLASS="sgmltag"
>phpini</CODE
> tag.
   </P
><P
>&#13;    A <CODE
CLASS="sgmltag"
>global</CODE
> definition requires the
    <TT
CLASS="literal"
>name=...</TT
> and <TT
CLASS="literal"
>type=...</TT
>
    attributes to be set as valid C names and types. Which C types are
    allowed depends on what type definitions have been included from
    header files. The available types are not known when
    <TT
CLASS="literal"
>pecl-gen</TT
> parses the XML specification so that
    types are only checked for valid name format here. Specifying a
    type that is not a basic C type or defined in any included file
    will lead to error messages when compiling the generated extension
    code later.
   </P
><P
>&#13;    Initial values may be specified using the
    <TT
CLASS="literal"
>value=...</TT
> attribute. This feature should only
    be used for simple numeric values, anything more complex should
    better be initialized within the extensions
    <TT
CLASS="literal"
>RINIT()</TT
> function. 
   </P
><P
>&#13;    <TT
CLASS="literal"
>php.ini</TT
> directives may be defined using the
    <CODE
CLASS="sgmltag"
>phpini</CODE
> within a <CODE
CLASS="sgmltag"
>globals</CODE
>
    environment. To define a <TT
CLASS="literal"
>php.ini</TT
> directive you
    have to specify its name, type and default value using the
    <TT
CLASS="literal"
>name=...</TT
>, <TT
CLASS="literal"
>type=...</TT
> and
    <TT
CLASS="literal"
>value=...</TT
> attributes.
   </P
><P
>&#13;    Valid directive names are C variable names. The actual directive
    name is the extension name followed by a single dot
    '<TT
CLASS="literal"
>.</TT
>' and the specified name. Valid directive
    types are <SPAN
CLASS="type"
>bool</SPAN
>, <SPAN
CLASS="type"
>int</SPAN
>, <SPAN
CLASS="type"
>float</SPAN
>
    and <SPAN
CLASS="type"
>string</SPAN
>.
   </P
><P
>&#13;    Directive default values are passed to the engine as strings, so
    you may not use any C constants or preprocessor macros here. The
    default value strings are parsed by the
    <TT
CLASS="literal"
>OnUpdate</TT
> handler registered for that
    directive. No value checking takes place during extension code
    generation or compilation, this is done by the registered
    <TT
CLASS="literal"
>OnUpdate</TT
> handler at runtime during request
    initialization. The <TT
CLASS="literal"
>OnUpdate</TT
> handler defaults
    to the appropriate internal
    <TT
CLASS="literal"
>OnUpdate</TT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>type</I
></SPAN
> handler
    unless you specify a different handler using the
    <TT
CLASS="literal"
>onupdate=...</TT
> attribute.
   </P
><P
>&#13;    The directive value may be changed at any time unless you specify
    an <TT
CLASS="literal"
>access=...</TT
> attribute. Possible values are:
    <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>system</DT
><DD
><P
>&#13;        may only be set globally in <TT
CLASS="literal"
>php.ini</TT
> or the
        web server configuration
       </P
></DD
><DT
>perdir</DT
><DD
><P
>&#13;        may be changed in local <TT
CLASS="literal"
>.htaccess</TT
> files
       </P
></DD
><DT
>user</DT
><DD
><P
>may be changed by PHP code</P
></DD
><DT
>all</DT
><DD
><P
>may be changed by anyone at any time</P
></DD
></DL
></DIV
>
   </P
><P
>&#13;    The content data of <CODE
CLASS="sgmltag"
>phpini</CODE
> tags is used to
    generate documentation for the defined
    directive. <CODE
CLASS="sgmltag"
>global</CODE
> definitions may also include
    content data but it is for internal documentation only, it is not
    used in DocBook XML generation (yet).
   </P
><DIV
CLASS="example"
><A
NAME="AEN362"
></A
><P
><B
>Example 2-12. Globals</B
></P
><PRE
CLASS="programlisting"
>&#13;
...
 &#60;globals&#62;
  &#60;global name="sample_int"    type="int"    value="42" /&#62;
  &#60;global name="sample_float"  type="float"  value="3.14" /&#62;
  &#60;global name="SAMPLE_STRING" type="char *" /&#62;

  &#60;phpini name="my_int" type="int" value="42" onupdate="OnUpdateLong" access="all"&#62;
   Definition for directive "sample.my_int"
  &#60;/phpini&#62;
 &#60;/globals&#62;
...

    </PRE
></DIV
><P
>&#13;    Access to the modul globals and ini parameters is provided in a thread safe 
    manner through the EXTNAME_G() macro (replace EXTNAME with the upper cased
    name of your extension).
   </P
><DIV
CLASS="example"
><A
NAME="AEN366"
></A
><P
><B
>Example 2-13. Globals</B
></P
><PRE
CLASS="programlisting"
>&#13;
&#60;extension name="foobar"&#62;
 ...
 &#60;globals&#62;
  &#60;global name="sample_int"    type="int"    value="42" /&#62;
 &#60;/globals&#62;
 ...
 &#60;function ...&#62;
  ...
  &#60;code&#62;
   ...
   int foo = FOOBAR_G(sample_int); // get global value 
   ...
   FOOBAR_G(sample_init) = 42; // set global value
   ...
  &#60;/code&#62;
 &#60;/function&#62;

    </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN369"
>2.8. Resources</A
></H2
><P
>&#13;    You may define PHP resource types within a
    <CODE
CLASS="sgmltag"
>resources</CODE
> environment. For each
    <CODE
CLASS="sgmltag"
>resource</CODE
> you have to specify the
    <TT
CLASS="literal"
>name=...</TT
> and <TT
CLASS="literal"
>payload=...</TT
>
    attributes. The <TT
CLASS="literal"
>name</TT
> has to be a valid 
    C name and the <TT
CLASS="literal"
>payload</TT
> has to be a valid 
    C type specifier. The payload type can only be checked for 
    the correctness of its form as the actual type definitions 
    from included header files are not known to the extension 
    generator when it generates the extension code.
   </P
><P
>&#13;    The actual resource data structure carries a pointer to the
    payload type. You may specify that PHP shall allocate and free
    the actual payload by setting the <TT
CLASS="literal"
>alloc=...</TT
>
    attribute to "<TT
CLASS="literal"
>yes</TT
>". If the payload is allocated
    by a library function or by yourself you should set 
    <TT
CLASS="literal"
>alloc=...</TT
> to "<TT
CLASS="literal"
>no</TT
>" 
    (the default value).
   </P
><P
>&#13;    Resources are destructed when the last variable reference refering
    to them is unset or at request shutdown. If your resource
    payload needs to be cleaned up as well you have to add an
    appropriate C code snippet that takes care of this using the
    <CODE
CLASS="sgmltag"
>destruct</CODE
> tag. Within the destructor snippet you
    may refer to the allocated payload using the
    <TT
CLASS="literal"
>resource</TT
> pointer variable.
   </P
><P
>&#13;    You don't need to take care of destruction yourself if  your
    resource payload is allocated by PHP (<TT
CLASS="literal"
>alloc="yes"</TT
>) 
    and needs no further cleanup work besides releasing the allocated memory.
   </P
><DIV
CLASS="example"
><A
NAME="AEN388"
></A
><P
><B
>Example 2-14. Resources</B
></P
><PRE
CLASS="programlisting"
>&#13;
...
  &#60;resources&#62;
    &#60;resource name="sample_resource" payload="float" alloc="yes"&#62;
      &#60;description&#62;
        A simple floating point resource
      &#60;/description&#62;
      &#60;!-- no &#60;destruct&#62; needed due to the alloc attribute --&#62;
    &#60;/resource&#62;

    &#60;resource name="sample_struct" payload="struct foobar" alloc="no"&#62;
      &#60;description&#62;
        A foobar resource managed by an external foobar lib.
      &#60;/description&#62;
      &#60;destruct&#62;
        foobar_release(resource);
      &#60;/destruct&#62;
    &#60;/resource&#62;
  &#60;/resources&#62;
...

    </PRE
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN391"
>2.8.1. Resource creation and destruction</A
></H3
><P
>&#13;     The creation of resource instances is not defined within
     <CODE
CLASS="sgmltag"
>resource</CODE
>. This is a task to be handled by
     public PHP functions instead.
    </P
><DIV
CLASS="example"
><A
NAME="AEN395"
></A
><P
><B
>Example 2-15. Resource creation</B
></P
><PRE
CLASS="screen"
>&#13;
  &#60;function name="foo_open"&#62;
   &#60;proto&#62;resource foo foo_open(string path)&#60;/proto&#62;
   &#60;code&#62;
    return_res = foo_open(path);

    if (!return_res) RETURN_FALSE;
   &#60;/code&#62;
  &#60;/function&#62;

     </PRE
></DIV
><P
>&#13;     Resources are freed by simply removing them from the 
     resource list that they are in. The resources destructor
     function is automaticly called on list removal.
    </P
><DIV
CLASS="example"
><A
NAME="AEN399"
></A
><P
><B
>Example 2-16. Resource destruction</B
></P
><PRE
CLASS="screen"
>&#13;
  &#60;function name="foo_close"&#62;
   &#60;proto&#62;void foo_close(resource foo foores)&#60;/proto&#62;
   &#60;code&#62;
     zend_list_delete(Z_LVAL_P(foores));
   &#60;/code&#62;
  &#60;/function&#62;

     </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN402"
>2.9. Classes</A
></H2
><P
>&#13;    OO support is planned for a future release but not implemented yet.
    OO code generation may be limited to PHP 5 extensions as unlike the
    rest of the extension API the OO implementation changed a lot between
    PHP 4 and 5.
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN405"
>2.10. Streams</A
></H2
><P
>&#13;    Stream filter and wrapper support is experimental and not yet added
    to the released code base.
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN408"
>2.11. config.m4 fragments</A
></H2
><P
>&#13;    Additional configure checks can be added to the generated config.m4
    file used by Unix/Cygwin builds using the <CODE
CLASS="sgmltag"
>configm4</CODE
> 
    tag. Using the 'position' attribute it is possible to specify whether
    the additional code is to be added at the top or bottom of the 
    config.m4 file.
   </P
><DIV
CLASS="example"
><A
NAME="AEN412"
></A
><P
><B
>Example 2-17. config.m4 additions</B
></P
><PRE
CLASS="screen"
>&#13;
&#60;configm4&#62;
  AC_CHECK_PROG(RE2C, re2c, re2c)
  PHP_SUBST(RE2C)
&#60;/configm4&#62;

    </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN415"
>2.12. Makefile fragments</A
></H2
><P
>&#13;    Makefile rules may be added using the
    <CODE
CLASS="sgmltag"
>makefile</CODE
> for Unix/Cygwin builds.
    Using this it is possible to add dependencies or build rules in
    addition to the default and auto generated rules.
   </P
><DIV
CLASS="example"
><A
NAME="AEN419"
></A
><P
><B
>Example 2-18. Makefile fragments</B
></P
><PRE
CLASS="screen"
>&#13;
&#60;makefile&#62;
$(builddir)/scanner.c: $(srcdir)/scanner.re
  $(RE2C) $(srcdir)/scanner.re &#62; $@
&#60;/makefile&#62;

    </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN422"
>2.13. Tests</A
></H2
><P
>&#13;    For now <TT
CLASS="literal"
>PECL_Gen</TT
> generates one test case
    skeleton for every function prototype. 
   </P
><P
>&#13;    Support for customizable test script generation is planned for a
    future release.
   </P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="AEN427"
></A
>Chapter 3. XML input parsing</H1
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN429"
>3.1. Includes</A
></H2
><P
>&#13;	The XML parser used by <TT
CLASS="literal"
>PECL_Gen</TT
> supports inclusion
    of additional source files using three different ways:
    <P
></P
><UL
><LI
><P
>external entities</P
></LI
><LI
><P
>a subset of XInclude</P
></LI
><LI
><P
>the <TT
CLASS="literal"
>source</TT
> attribute of <CODE
CLASS="sgmltag"
>code</CODE
> tags</P
></LI
></UL
>
   </P
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN442"
>3.1.1. External entities</A
></H3
><P
>&#13;    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN445"
>3.1.2. XInclude</A
></H3
><P
>&#13;    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN448"
>3.1.3. <CODE
CLASS="sgmltag"
>code</CODE
> tags</A
></H3
><P
>&#13;    </P
></DIV
></DIV
></DIV
></DIV
></BODY
></HTML
>